// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(x) {
    return x.clone();
  })({
    version: "makefile-coffee 0.3.0",
    RegExp: RegExp,
    fs: require('fs'),
    touch: require('touch'),
    execSync: require('execSync'),
    setTimeout: setTimeout,
    clearTimeout: clearTimeout,
    ruleToRx: function(x) {
      var escaperx;
      escaperx = function(str) {
        return str.replace(/[.^$*+?()[{\\|\]-]/g, '\\$&');
      };
      return new this.RegExp("^" + escaperx(x).replace("%", "(.*)") + "$");
    },
    maxDepth: 7,
    rule: function() {
      var args, deps, k, opts, t, target, task, v, x;
      args = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          x = arguments[_i];
          _results.push(x);
        }
        return _results;
      }).apply(this, arguments);
      target = null;
      deps = [];
      task = null;
      opts = {};
      while (args.length) {
        x = args.shift();
        t = typeof x;
        if (t === "string") {
          if (target == null) {
            target = x;
          } else {
            deps.push(x);
          }
        } else if (t === "function") {
          task = x;
        } else if (t === "object") {
          for (k in x) {
            v = x[k];
            opts[k] = v;
          }
        }
      }
      if (/%/.test(target)) {
        this.trace("Adding rule for " + target);
        this.rules.push({
          target: target,
          deps: deps,
          opts: opts,
          task: task,
          rx: this.ruleToRx(target)
        });
      } else {
        delete this.targets[target];
        this.trace("Adding rule for " + target);
        this.targets[target] = {
          deps: deps,
          opts: opts,
          task: task
        };
      }
      return this;
    },
    'var': function() {
      var args, name, x;
      args = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          x = arguments[_i];
          _results.push(x);
        }
        return _results;
      }).apply(this, arguments);
      name = args.shift();
      delete this.vars[name];
      if (args.length > 0) {
        this.vars[name] = args.join(' ');
      } else {
        this.vars[name] = name;
      }
      return this;
    },
    sh: function() {
      var args, cmd, cmdparts, k, opt, retCode, t, v, x, _i, _len;
      args = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          x = arguments[_i];
          _results.push(x);
        }
        return _results;
      }).apply(this, arguments);
      cmdparts = [];
      opt = {};
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        x = args[_i];
        t = typeof x;
        if (t === 'string') {
          cmdparts.push(x);
        } else {
          for (k in x) {
            v = x[k];
            opt[k] = v;
          }
        }
      }
      cmd = cmdparts.join(' ');
      if (opt.out) {
        cmd = cmd + ' >' + opt["out"];
      }
      if (opt["in"]) {
        cmd = cmd + ' <' + opt["in"];
      }
      this.show(cmd);
      if (!this.testRun) {
        retCode = this.execSync.run(cmd);
      }
      if (retCode !== 0) {
        throw "Shell command failed: " + cmd;
      }
    },
    vars: [],
    rules: [],
    targets: {},
    clone: function() {
      var k, v, y;
      y = (function(_arg) {
        var rule;
        rule = _arg.rule;
        return function() {
          return rule.apply(y, arguments);
        };
      })(this);
      for (k in this) {
        v = this[k];
        y[k] = v;
      }
      y;
      y.vars = this.vars.slice(0);
      y.rules = this.rules.slice(0);
      y.targets = (function(_this) {
        return function(x) {
          var _ref;
          _ref = _this.targets;
          for (k in _ref) {
            v = _ref[k];
            x[k] = v;
          }
          return x;
        };
      })(this)({});
      return y;
    },
    process: process,
    echo: function() {
      var args, x;
      args = [
        (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arguments.length; _i < _len; _i++) {
            x = arguments[_i];
            _results.push(x);
          }
          return _results;
        }).apply(this, arguments)
      ];
      this.process.stdout.write(args.join(' ') + "\n");
      return this;
    },
    setup: function(s) {
      if (s != null) {
        s.apply(this);
      }
      return this;
    },
    setupMakefile: function(f) {
      var add, c, error, heading, line, lineno, match, rule, _i, _len, _ref;
      if (this.fs.existsSync(f)) {
        try {
          c = this.fs.readFileSync(f);
          if ((c = c.toString()) == null) {
            throw "Could not decode file";
          }
        } catch (_error) {
          error = _error;
          this.error("Could not read " + f + ": " + error);
        }
        lineno = 0;
        add = (function(_this) {
          return function(heading, rule) {
            var args;
            rule = (function(rule) {
              var compile, x;
              compile = function(x) {
                var y, z, _i, _len;
                if (x === "") {
                  return (function() {});
                }
                x = x.split(/([$][(][^)]*[)])/);
                y = [];
                for (_i = 0, _len = x.length; _i < _len; _i++) {
                  z = x[_i];
                  y = y.concat(z.split(/([$][^(])/));
                }
                return function() {
                  var b, cmd, match, n, retCode;
                  x = (function() {
                    var _j, _len1, _results;
                    _results = [];
                    for (_j = 0, _len1 = y.length; _j < _len1; _j++) {
                      z = y[_j];
                      if ((match = /^[$][(]([^)]*)[)$]/.exec(z)) != null) {
                        n = match[1];
                        _results.push(this.v[n]);
                      } else if ((match = /^[$](.)$/.exec(z)) != null) {
                        b = match[1];
                        if (b === "@") {
                          _results.push(this.out);
                        } else if (b === "^") {
                          _results.push(this.deps.join(' '));
                        } else if (b === "<") {
                          _results.push(this["in"]);
                        } else {
                          _results.push(this.error("Unknown variable identifier in " + f + ": '$" + b + "'"));
                        }
                      } else {
                        _results.push(z);
                      }
                    }
                    return _results;
                  }).call(this);
                  cmd = x.join('');
                  this.show(cmd);
                  if (!this.testRun) {
                    retCode = this.execSync.run(cmd);
                    if (retCode !== 0) {
                      throw "Shell command failed: " + cmd;
                    }
                  }
                };
              };
              rule = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = rule.length; _i < _len; _i++) {
                  x = rule[_i];
                  _results.push(compile(x));
                }
                return _results;
              })();
              return function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = rule.length; _i < _len; _i++) {
                  x = rule[_i];
                  _results.push(x.call(this));
                }
                return _results;
              };
            })(rule);
            args = [heading[1]];
            args = args.concat(heading[2].trim().split(/\ +/));
            args.push(rule);
            return _this.apply(_this, args);
          };
        })(this);
        heading = null;
        rule = [];
        _ref = c.split("\n");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          lineno++;
          line = line.trim();
          if ((match = /^([^\ ]+)=(.*)$/.exec(line)) != null) {
            this.vars[match[1]] = match[2];
          } else if ((match = /^([^\ ]*):(.*)$/.exec(line)) != null) {
            if (heading != null) {
              add(heading, rule);
              rule = [];
            }
            heading = match;
          } else {
            rule.push(line);
          }
        }
        if (heading != null) {
          return add(heading, rule);
        }
      } else {
        return this.error("File '" + f + "' does not exist!");
      }
    },
    error: function(msg) {
      this.echo(msg);
      this.process.exit(1);
      throw "Could not exit after error: " + msg;
    },
    assertTrue: function(msg, cond) {
      if (!cond) {
        throw "Internal error: " + msg;
      }
    },
    info: function(msg) {
      if (this.verboseness >= 1) {
        this.echo(msg);
      }
      return this;
    },
    show: function(msg) {
      if (this.verboseness >= 0) {
        this.echo(msg);
      }
      return this;
    },
    trace: function(msg) {
      if (this.verboseness >= 2) {
        this.echo(msg);
      }
      return this;
    },
    debug: function(msg) {
      if (this.verboseness >= 3) {
        this.echo(msg);
      }
      return this;
    },
    makeNow: function(target) {
      var dep, entry, _i, _len, _ref;
      entry = this.target[target];
      this.depsRequired || (this.depsRequired = {});
      if (entry != null) {
        _ref = entry.deps;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dep = _ref[_i];
          if (this.depsRequired[dep] != null) {
            this.info("Ignored circular or duplicate dependency: " + dep);
          } else {
            true;
          }
        }
      }
      return this;
    },
    make: function(target) {
      return (this.toMake || (this.toMake = {}))[target] = 1;
    },
    verboseness: 0,
    options: {
      help: function(args) {
        console.log("Options:\n-f FILE    Read FILE as Makefile\n--watch    Rebuild the current directory for changes\n--test     Test run: print shell commands instead of executing them\n--rebuild  Rebuild targets ignoring modification times\n--quiet    Do not show messages\n--verbose  Increase verboseness\n--help     Show this help");
        return this.process.exit();
      },
      rebuild: function(args) {
        return this.ignoreMtime = true;
      },
      watch: function(args) {
        return this.action = 'watchAction';
      },
      verbose: function(args) {
        return this.verboseness++;
      },
      quiet: function(args) {
        return this.verboseness = -1;
      },
      delay: function(args) {
        return this.buildDelay = args.shift();
      },
      test: function(args) {
        return this.testRun = true;
      },
      f: function(args) {
        if (this.defaultMakefile != null) {
          this.defaultMakefile = typeof null !== "undefined" && null !== null;
        }
        return (this.makefiles != null ? this.makefiles : this.makefiles = []).push(args.shift());
      }
    },
    processOption: function(name, args) {
      var x;
      if ((x = this.options[name]) != null) {
        return x.call(this, args);
      } else {
        return this.error("Unrecognized option: --" + name);
      }
    },
    action: 'buildAction',
    watchAction: function() {
      var timeout;
      timeout = null;
      this.buildAction();
      this.fs.watch('.', (function(_this) {
        return function(event, filename) {
          _this.trace("Event for " + filename);
          if (timeout) {
            _this.clearTimeout(timeout);
            timeout = null;
          }
          return timeout = _this.setTimeout((function() {
            return _this.buildAction();
          }), _this.buildDelay);
        };
      })(this));
      return this;
    },
    buildAction: function() {
      var x;
      this.targetsChecked = {};
      this.targetsBuilt = {};
      for (x in this.toMake) {
        this.tryMake(x);
      }
      return this;
    },
    fileExists: function(x) {
      return this.fs.existsSync(x);
    },
    depExists: function(x) {
      return this.targetsBuilt[x] || this.fileExists(x);
    },
    fileTime: function(f) {
      var error, s;
      try {
        s = this.fs.statSync(f);
      } catch (_error) {
        error = _error;
        return null;
      }
      return s.mtime;
    },
    depTime: function(f) {
      var s;
      s = this.fs.statSync(f);
      return s.mtime;
    },
    isTargetNewer: function(target, deps) {
      var d, t, tt, _i, _len;
      if (this.ignoreMtime) {
        return true;
      }
      if ((t = this.fileTime(target)) == null) {
        return false;
      }
      this.debug("deps: " + target);
      for (_i = 0, _len = deps.length; _i < _len; _i++) {
        d = deps[_i];
        this.assertTrue("Dependency " + target + " doesn't have a time", (tt = this.depTime(d)) != null);
        if (t <= tt) {
          return false;
        }
      }
      this.trace("newer");
      return true;
    },
    lib: {
      constants: require("constants")
    },
    touchFile: function(f) {
      if (this.testRun) {
        return;
      }
      return this.touch.sync(f);
    },
    tryBuild: function(target, deps, task, soft) {
      var error, error2, fileDidExistBefore, xx, _i, _len;
      this.debug("Try to build " + target);
      this.debug("Complain if some dependencies are missing.");
      for (_i = 0, _len = deps.length; _i < _len; _i++) {
        xx = deps[_i];
        if (xx === "") {
          continue;
        }
        if (!this.depExists(xx)) {
          (soft ? this.trace : this.error).call(this, "A required dependency is missing: " + xx);
          return;
        }
      }
      if (!this.isTargetNewer(target, deps)) {
        this.trace("Building target: " + target + " with deps " + (deps.join(',')));
        this.dep = deps;
        this["in"] = deps[0];
        this.out = target;
        fileDidExistBefore = this.fileExists(target);
        try {
          task.apply(this);
          return this.touchFile(target);
        } catch (_error) {
          error = _error;
          if (!fileDidExistBefore) {
            try {
              this.fs.unlinkSync(target);
            } catch (_error) {
              error2 = _error;
              true;
            }
          }
          throw error;
        }
      }
    },
    tryMake: function(x, depth) {
      var d, deps, m, r, t, xx, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _results;
      if (depth == null) {
        depth = 0;
      }
      depth++;
      if (depth > this.maxDepth) {
        return;
      }
      if (this.targetsChecked[x] != null) {
        this.trace("" + x + " already checked, skipping");
        return;
      }
      this.info("Checking status of " + x);
      this.targetsChecked[x] = 1;
      if ((t = this.targets[x]) != null) {
        _ref = t.deps;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          xx = _ref[_i];
          this.tryMake(xx, depth);
        }
        return this.tryBuild(x, t.deps, t.task);
      } else {
        this.debug("No explicit target found, checking rules for " + x);
        _ref1 = this.rules;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          r = _ref1[_j];
          if ((m = r.rx.exec(x)) != null) {
            this.trace("Rule " + r.target + " <- " + ((_ref2 = r.deps[0]) != null ? _ref2 : "''") + " matches!");
            deps = (function() {
              var _k, _len2, _ref3, _results1;
              _ref3 = r.deps;
              _results1 = [];
              for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                d = _ref3[_k];
                _results1.push(d.replace("%", m[1]));
              }
              return _results1;
            })();
            for (_k = 0, _len2 = deps.length; _k < _len2; _k++) {
              xx = deps[_k];
              this.tryMake(xx, depth);
            }
            this.tryBuild(x, deps, r.task, true);
            _results.push(this.debug("Rule " + r.target + " <- " + ((_ref3 = r.deps[0]) != null ? _ref3 : "''") + " matches! DONE"));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    },
    performAction: function() {
      var k, lastTarget, v, x, _i, _len, _ref, _ref1;
      if ((this.makefiles == null) && (this.defaultMakefile != null)) {
        this.makefiles = [this.defaultMakefile];
      }
      if (this.makefiles != null) {
        _ref = this.makefiles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          this.setupMakefile(x);
        }
      }
      if (this.toMake == null) {
        lastTarget = null;
        _ref1 = this.targets;
        for (k in _ref1) {
          v = _ref1[k];
          lastTarget = k;
        }
        if (lastTarget == null) {
          this.error("No targets defined!");
        }
        this.make(lastTarget);
      }
      return this[this.action].apply(this);
    },
    processOptions: function(args) {
      var m, x;
      while (args.length) {
        x = args.shift();
        if ((m = /^--(.*)$/.exec(x)) != null) {
          if (m[1] === '') {
            break;
          }
          this.processOption(m[1], args);
        } else if ((m = /^-(.)$/.exec(x)) != null) {
          this.processOption(m[1], args);
        } else {
          this.make(x);
        }
      }
      while (args.length) {
        x = args.shift();
        this.make(x);
      }
      return this;
    },
    withProcessArgs: function(cb) {
      var args, argv, process, progname;
      process = this.process;
      argv = process.argv;
      args = /([/]|^)(node(js)?|coffee)([.]exe)?$/i.test(argv[0]) ? argv.slice(1) : argv.slice(0);
      progname = args.shift();
      cb.call(this, args, {
        progname: progname
      });
      return this;
    },
    run: function(setup) {
      return this.withProcessArgs(function(args) {
        return this.runWithArgs(args, setup);
      });
    },
    runWithArgs: function(args, setup) {
      this.v = this.vars;
      return this.processOptions(args).setup(setup).performAction();
    },
    runStandalone: function(_arg) {
      var process;
      process = _arg.process;
      this.defaultMakefile = 'Makefile';
      if (process != null) {
        this.process = process;
      }
      return this.withProcessArgs(function(args) {
        return this.runWithArgs(args);
      });
    }
  });

}).call(this);
